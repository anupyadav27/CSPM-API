import Vulnerability from "../models/vulnerability.js";
import auditLogServices from "../services/auditLogServices.js";

const vulnerabilityServices = {
    async createVulnerability(data, userId, req = {}) {
        try {
            if (!data?.tenantId) throw new Error("tenantId is required");
            if (!data?.assetId) throw new Error("assetId is required");

            const vuln = await Vulnerability.create({
                ...data,
            });

            await auditLogServices.createLog({
                tenantId: vuln.tenantId,
                userId,
                action: "create",
                entityType: "Vulnerability",
                entityId: vuln._id,
                description: `Created vulnerability ${vuln.title}`,
                after: vuln.toObject(),
                req,
            });

            return { success: true, vulnerability: vuln };
        } catch (err) {
            console.error("Error creating vulnerability:", err);
            throw err;
        }
    },

    async getAllVulnerabilities(filters = {}, pagination = {}) {
        try {
            const query = Vulnerability.find(filters)
                .populate("tenantId", "_id name")
                .populate("assetId", "_id name")
                .sort({ createdAt: -1 });

            let vulnerabilities, total;

            if (pagination.enabled) {
                const { skip, pageSize } = pagination;

                [vulnerabilities, total] = await Promise.all([
                    query.skip(skip).limit(pageSize).lean(),
                    Vulnerability.countDocuments(filters),
                ]);
            } else {
                vulnerabilities = await query.lean();
                total = vulnerabilities.length;
            }

            return {
                success: true,
                vulnerabilities,
                pagination: {
                    total,
                    pageSize: pagination.enabled ? pagination.pageSize : total,
                    currentPage: pagination.enabled
                        ? Math.floor(pagination.skip / pagination.pageSize) + 1
                        : 1,
                    totalPages: pagination.enabled ? Math.ceil(total / pagination.pageSize) : 1,
                },
            };
        } catch (err) {
            console.error("Error fetching vulnerabilities:", err);
            throw err;
        }
    },

    async getVulnerabilitiesByTenant(tenantId, filters = {}, pagination = {}) {
        try {
            if (!tenantId) throw new Error("tenantId is required");

            const query = Vulnerability.find({ tenantId, ...filters })
                .populate("tenantId", "_id name")
                .populate("assetId", "_id name")
                .sort({ createdAt: -1 });

            let vulnerabilities, total;

            if (pagination.enabled) {
                const { skip, pageSize } = pagination;
                [vulnerabilities, total] = await Promise.all([
                    query.skip(skip).limit(pageSize).lean(),
                    Vulnerability.countDocuments({ tenantId, ...filters }),
                ]);
            } else {
                vulnerabilities = await query.lean();
                total = vulnerabilities.length;
            }

            return {
                success: true,
                vulnerabilities,
                pagination: {
                    total,
                    pageSize: pagination.enabled ? pagination.pageSize : total,
                    currentPage: pagination.enabled
                        ? Math.floor(pagination.skip / pagination.pageSize) + 1
                        : 1,
                    totalPages: pagination.enabled ? Math.ceil(total / pagination.pageSize) : 1,
                },
            };
        } catch (err) {
            console.error("Error fetching vulnerabilities by tenant:", err);
            throw err;
        }
    },

    async getVulnerabilitiesByAsset(assetId, filters = {}, pagination = {}) {
        try {
            if (!assetId) throw new Error("assetId is required");

            const query = Vulnerability.find({ assetId, ...filters })
                .populate("tenantId", "_id name")
                .populate("assetId", "_id name")
                .sort({ createdAt: -1 });

            let vulnerabilities, total;

            if (pagination.enabled) {
                const { skip, pageSize } = pagination;
                [vulnerabilities, total] = await Promise.all([
                    query.skip(skip).limit(pageSize).lean(),
                    Vulnerability.countDocuments({ assetId, ...filters }),
                ]);
            } else {
                vulnerabilities = await query.lean();
                total = vulnerabilities.length;
            }

            return {
                success: true,
                vulnerabilities,
                pagination: {
                    total,
                    pageSize: pagination.enabled ? pagination.pageSize : total,
                    currentPage: pagination.enabled
                        ? Math.floor(pagination.skip / pagination.pageSize) + 1
                        : 1,
                    totalPages: pagination.enabled ? Math.ceil(total / pagination.pageSize) : 1,
                },
            };
        } catch (err) {
            console.error("Error fetching vulnerabilities by asset:", err);
            throw err;
        }
    },

    async updateVulnerability(vulnId, updateData, userId, req = {}) {
        try {
            if (!vulnId) throw new Error("vulnerability ID is required");

            const before = await Vulnerability.findById(vulnId)
                .populate("tenantId", "_id name")
                .populate("assetId", "_id name")
                .lean();

            if (!before) throw new Error("Vulnerability not found");

            updateData.lastUpdatedAt = new Date();

            const updated = await Vulnerability.findByIdAndUpdate(
                vulnId,
                { $set: updateData },
                { new: true, runValidators: true }
            )
                .populate("tenantId", "_id name")
                .populate("assetId", "_id name")
                .lean();

            await auditLogServices.createLog({
                tenantId: before.tenantId?._id || before.tenantId,
                userId,
                action: "update",
                entityType: "Vulnerability",
                entityId: vulnId,
                description: `Updated vulnerability ${before.title}`,
                before,
                after: updated,
                req,
            });

            return { success: true, vulnerability: updated };
        } catch (err) {
            console.error("Error updating vulnerability:", err);
            throw err;
        }
    },

    async deleteVulnerability(vulnId, userId, req = {}) {
        try {
            if (!vulnId) throw new Error("vulnerability ID is required");

            const before = await Vulnerability.findById(vulnId)
                .populate("tenantId", "_id name")
                .populate("assetId", "_id name")
                .lean();

            if (!before) throw new Error("Vulnerability not found");

            await Vulnerability.findByIdAndDelete(vulnId);

            await auditLogServices.createLog({
                tenantId: before.tenantId?._id || before.tenantId,
                userId,
                action: "delete",
                entityType: "Vulnerability",
                entityId: vulnId,
                description: `Deleted vulnerability ${before.title}`,
                before,
                req,
                severity: "warning",
            });

            return {
                success: true,
                message: `Vulnerability ${before.title || vulnId} deleted successfully`,
            };
        } catch (err) {
            console.error("Error deleting vulnerability:", err);
            throw err;
        }
    },
};

export default vulnerabilityServices;
